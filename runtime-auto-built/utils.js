window.runTimeData.utils = {"Contents":"/*\r\n\r\n  About utils.js:\r\n\r\n  This is shared by both the editor and the runtime (meaning it is injected\r\n    into every exported story)!\r\n\r\n  Functions that are needed by both the editor and the runtime should go here,\r\n  so they don't need to be duplicated.\r\n\r\n*/\r\n\r\n\r\nconst utils = {\r\n\r\n  isObj(v) {\r\n    //is it actual object, the way I mean it; not an\r\n    //array and not null and not a function\r\n    return typeof v === 'object' && v !== null && !isArray(v)\r\n  },\r\n  \r\n  isArray(v) {\r\n    return Array.isArray(v)\r\n  },\r\n\r\n  isInteger(v) {\r\n    //true integer, not a string containing an integer\r\n    //not sure if this is 100% correct, but seems to work\r\n    return Math.round(Number(v)) === v\r\n  },\r\n\r\n  isString(n) {\r\n    return typeof n === 'string' || n instanceof String\r\n  },\r\n\r\n\r\n  isFunc(func) {\r\n    return func && {}.toString.call(func) === '[object Function]';\r\n  },\r\n\r\n  getRndInt(min, max) {\r\n    if (!max && max !== 0) throw new Error(\"getRndInt must be passed two parameters.\")\r\n    return Math.floor(Math.random() * (max - min + 1)) + min\r\n  },\r\n\r\n  oneOf(arr) {\r\n    return arr[utils.getRndInt(0, arr.length-1)]\r\n  },\r\n\r\n  filterIfPrevious(list, compare) {\r\n    /* takes array and function.\r\n      for each item (except for the first one in array because\r\n        it has no previous item),\r\n      the function is passed the previous item and\r\n      the current item. if the function returns\r\n      false, the current item is discarded, if it returns\r\n      true, it is kept inside the list.\r\n      The first item ALWAYS remains in the list.\r\n      This does not mutate the original list.\r\n      The idea is to filter a list according to the \r\n      criterium \"the item that came before it\",\r\n      for example to remove duplicate entries.\r\n      Note: even if an item is filtered out, it still\r\n      gets passed to the next entry as previous item.\r\n      list = [1, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7]\r\n      list = filterIfPrevious( list, (prev, item) => prev !== item )\r\n      -> [1, 2, 3, 4, 5, 6, 7]\r\n      list = filterIfPrevious( list, (prev, item) => prev === item )\r\n      -> [1, 1, 1, 4, 7] (first item always stays, even if its predecessor\r\n        is technically not equal to itself)\r\n    */\r\n    let newList = []\r\n    let prev\r\n    let index = -1\r\n    for (let item of list) {\r\n       index++\r\n       if (index === 0 || compare(prev, item)) {\r\n         newList.push(item)\r\n       }\r\n       prev = item\r\n    }\r\n    return newList\r\n  },\r\n\r\n\r\n  filterIfNext(list, compare) {\r\n    /* takes array and function.\r\n      Like filterIfPrevious, but for next item.\r\n      Last item is always kept.\r\n\r\n      list = [1, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7]\r\n      list = utils.filterIfNext( list, (prev, item) => prev === item )\r\n      console.log(list)\r\n      //-> 1, 1, 4, 7, 7\r\n      //(keep all numbers where the next number is equal to it, as well as the very last 7)\r\n\r\n      list = [1, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7]\r\n      list = utils.filterIfNext( list, (prev, item) => prev !== item )\r\n      console.log(list)\r\n      //-> 1, 2, 3, 4, 5, 6, 7\r\n    */\r\n    let newList = []\r\n    let index = -1\r\n    for (let item of list) {\r\n       index++\r\n       const next = list[index + 1]\r\n       if (index === list.length - 1 || compare(item, next)) {\r\n         newList.push(item)\r\n       }\r\n    }\r\n    return newList\r\n  },\r\n\r\n  splitIntoPartsByStartAndEndTags(str, start = \"<<\", end = \">>\") {\r\n    /*\r\n    takes a text string, a start string (some character sequence)\r\n      and an end string (also some character sequence).\r\n    splits the text string and puts the individual parts\r\n    into an array. returns the array.\r\n\r\n    Example:\r\n      \"123  <<456>>789<<abc>>def\"\r\n    -> would return: ->\r\n    [\r\n      {inside: false, text: \"123  \"},\r\n      {inside: true, text: \"456\"},\r\n      {inside: false, text: \"789\"},\r\n      {inside: true, text: \"abc\"},\r\n      {inside: false, text: \"def\"},\r\n    ]\r\n\r\n    So it basically splits the strings at the indices\r\n    delineated by the start/end sequences and\r\n    returns the individual parts of the text.\r\n\r\n    Notes:\r\n    \r\n    - Maximum length of start and end strings is 2, min length is 1.\r\n\r\n    - The returned array can start with an \"inside: true\" element,\r\n    if the text string starts with the start sequence. Likewise\r\n    it can end with an \"inside: true\" element, if the text\r\n    string ends with the end sequence.\r\n\r\n    - the parts can span multiple lines\r\n\r\n    - The parts are NOT trimmed.\r\n\r\n    - Empty parts will not be included in the array, unless inside\r\n      start/end tags, so \"<<>>\" (when start === \"<<\" and end === \">>\")\r\n      would return this: [{inside: true, text: \"\"}],\r\n      whereas \"\" would just return an empty array.\r\n\r\n    - The start and end tokens CANNOT be used in a NESTED WAY!\r\n\r\n    - In some cases, special error objects are returned, instead\r\n      of the array:\r\n      \r\n      -- unclosed part (no end token found corresponding to start token)\r\n        code: \"unclosed\"\r\n\r\n      -- end token found, but no start token found\r\n        code: \"closed\"\r\n\r\n      -- nested tokens found (this is not allowed)\r\n        code: \"nested\"\r\n\r\n    */\r\n    if (start.length > 2 || start.length < 1) throw new Error(`start length > 2 or < 1`)\r\n    if (end.length > 2 || end.length < 1) throw new Error(`end length > 2 or < 1`)\r\n\r\n    if (start === end) throw new Error (`Starting and ending token must be different.`)\r\n\r\n    const parts = []\r\n    let inside = false\r\n    let lastPosition = 0\r\n    let lastI = 0\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str[i]\r\n      const lookAhead = str.substr(i, 2)\r\n      if (char === start || lookAhead === start) {\r\n        if (inside) {\r\n          return {\r\n            error: true,\r\n            code: `nested`,\r\n            index: i,\r\n          }\r\n        }\r\n        const part = str.substring(lastPosition, i)\r\n        lastPosition = i\r\n        if (start.length === 2) i++\r\n        inside = true\r\n        parts.push({\r\n          inside: false,\r\n          text: part,\r\n        })\r\n      } else if (char === end || lookAhead === end) {\r\n        if (!inside) {\r\n          return {\r\n            error: true,\r\n            code: `closed`,\r\n            index: i,\r\n          }\r\n        }\r\n        if (end.length === 2) i++\r\n        inside = false\r\n        const part = str.substring(lastPosition, i + 1)\r\n        parts.push({\r\n          inside: true,\r\n          text: part,\r\n        })\r\n        lastPosition = i + 1\r\n      } else if (i === str.length - 1) {\r\n        parts.push({\r\n          inside: false,\r\n          text: str.substr(lastPosition),\r\n        })\r\n      }\r\n      lastI = i\r\n    }\r\n    if (inside) {\r\n      return {\r\n        error: true,\r\n        code: `unclosed`,\r\n        index: lastPosition,\r\n      }\r\n    }\r\n\r\n    let parts2 = parts.filter( n => {\r\n      if (!n.inside && n.text === \"\") {return false}\r\n      return true\r\n    })\r\n\r\n    parts2.forEach( part => {\r\n      if (!part.inside) return\r\n      part.text = part.text.substring(start.length, part.text.length - end.length)\r\n    })\r\n\r\n    return parts2\r\n  }\r\n\r\n}\r\n\r\n;(function() {\r\n\r\n  const alias = [\r\n    [\"rnd\", \"getRndInt\"],\r\n  ]\r\n  for (let item of alias) {\r\n    utils[item[0]] = utils[item[1]]\r\n  }\r\n\r\n \r\n\r\n})()\r\n\r\n","Meta":"./utils.js"}