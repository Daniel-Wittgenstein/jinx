window.runTimeData.utils = {"Contents":"\nconst utils = {\n\n  isObj(v) {\n    //is it actual object, the way I mean it; not an\n    //array and not null and not a function\n    return typeof v === 'object' \u0026\u0026 v !== null \u0026\u0026 !is_array(v)\n  },\n  \n  isArray(v) {\n    return Array.isArray(v)\n  },\n  \n\n  isString(n) {\n    return typeof n === 'string' || n instanceof String\n  },\n\n\n  isFunc(func) {\n    return func \u0026\u0026 {}.toString.call(func) === '[object Function]';\n  },\n  \n \n  getRndInt(min, max) {\n    if (!max \u0026\u0026 max !== 0) throw new Error(\"getRndInt must be passed two parameters.\")\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  },\n\n  oneOf(arr) {\n    return arr[utils.getRndInt(0, arr.length-1)]\n  },\n\n  filterIfPrevious(list, compare) {\n    /* takes array and function.\n      for each item (except for the first one in array because\n        it has no previous item),\n      the function is passed the previous item and\n      the current item. if the function returns\n      false, the current item is discarded, if it returns\n      true, it is kept inside the list.\n      The first item ALWAYS remains in the list.\n      This does not mutate the original list.\n      The idea is to filter a list according to the \n      criterium \"the item that came before it\",\n      for example to remove duplicate entries.\n      Note: even if an item is filtered out, it still\n      gets passed to the next entry as previous item.\n      list = [1, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7]\n      list = filterIfPrevious( list, (prev, item) =\u003e prev !== item )\n      -\u003e [1, 2, 3, 4, 5, 6, 7]\n      list = filterIfPrevious( list, (prev, item) =\u003e prev === item )\n      -\u003e [1, 1, 1, 4, 7] (first item always stays, even if its predecessor\n        is technically not equal to itself)\n    */\n    let newList = []\n    let prev\n    let index = -1\n    for (let item of list) {\n       index++\n       if (index === 0 || compare(prev, item)) {\n         newList.push(item)\n       }\n       prev = item\n    }\n    return newList\n  },\n\n\n  filterIfNext(list, compare) {\n    /* takes array and function.\n      Like filterIfPrevious, but for next item.\n      Last item is always kept.\n\n      list = [1, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7]\n      list = utils.filterIfNext( list, (prev, item) =\u003e prev === item )\n      console.log(list)\n      //-\u003e 1, 1, 4, 7, 7\n      //(keep all numbers where the next number is equal to it, as well as the very last 7)\n\n      list = [1, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7]\n      list = utils.filterIfNext( list, (prev, item) =\u003e prev !== item )\n      console.log(list)\n      //-\u003e 1, 2, 3, 4, 5, 6, 7\n    */\n    let newList = []\n    let index = -1\n    for (let item of list) {\n       index++\n       const next = list[index + 1]\n       if (index === list.length - 1 || compare(item, next)) {\n         newList.push(item)\n       }\n    }\n    return newList\n  },\n\n}\n\n\n","Meta":"utils.js"}