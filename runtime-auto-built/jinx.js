window.runTimeData.jinx = {"Contents":" \r\n                        \r\n/*\r\ntodo:\r\n+ once-only choices\r\n+ api to directly go to paragraph or label and start running from there\r\nand a js function to go to paragraph or label\r\nthat can be called WHILE JINX IS RUNNING! -> provided by jinx for any runner to use\r\n+ runner api stuff\r\n   \r\ndone:\r\n+ <<>> text replacements work for choices, too\r\n+ if conditions for choices (on same line)\r\n\r\nnotes:\r\n+ inline choices and each turn functionality are things the runner can provide.\r\n+ they are not done by jinx\r\n \r\n\r\n*/\r\n  \r\njinx = (function() {\r\n\r\n  function createNewStory(... args) {\r\n    const story = new Story(... args)\r\n    //only expose public methods, leave other methods private:\r\n    const wrapper = {\r\n      setState: story.setState.bind(story),\r\n      getState: story.getState.bind(story),\r\n      getContents: story.getContents.bind(story),\r\n      selectChoice: story.selectChoice.bind(story),\r\n      jumpTo: story.jumpTo.bind(story),\r\n      resetState: story.resetState.bind(story),\r\n      kickOff: story.kickOff.bind(story),\r\n      setTextContentMetaData: story.setTextContentMetaData.bind(story),\r\n    }\r\n    return wrapper\r\n  }\r\n\r\n  function isString(x) {\r\n    return x + \"\" === x\r\n  }\r\n\r\n  const debug = {\r\n    log: 0,\r\n    logFlow: 0,\r\n    compilationTime: 0,\r\n    turtle: 0,\r\n    turtleSpeed: 0,\r\n  }\r\n\r\n  const GLUESYMBOL = \"<>\"\r\n\r\n  class Story {\r\n    constructor(str, onError, onEvent) {\r\n\r\n      if (!isString(str)) throw new Error(`Jinx story must be passed a string.`)\r\n\r\n      this.securityMax = 5_000 //max elements per turn to prevent infinite loops\r\n      this.onError = onError\r\n      this.onEvent = onEvent\r\n      let res = this.initStory(str)\r\n      if (res.error) {\r\n        res.type = \"compile error\"\r\n        this.invalid = true\r\n        onError(res)\r\n        const nope = () => {\r\n          throw `Story failed to compile. Cannot call this method.`\r\n        }\r\n        this.getState = nope\r\n        this.setState = nope\r\n        this.restart = nope\r\n        this.selectChoice = nope\r\n        this.compilationFailed = true\r\n        return\r\n      }\r\n\r\n      this.resetState()\r\n      \r\n    }\r\n\r\n    initStory(a) {\r\n\r\n      const timerString = \"Jinx story compilation - total time\"\r\n\r\n      if (debug.compilationTime) {\r\n        console.time(timerString)\r\n      }\r\n\r\n      let result\r\n\r\n      a = normalizeWhitespace(a)\r\n\r\n      if (debug.compilationTime) {console.time(\"tokenize time\")}\r\n      let lines = tokenize(a)\r\n      if (debug.compilationTime) {console.timeEnd(\"tokenize time\")}\r\n\r\n      if (lines.error) return lines\r\n\r\n      if (lines.length === 0) {\r\n        return {\r\n          error: true,\r\n          lineNr: -1000,\r\n          lineObj: false,\r\n          msg: `Empty story.`\r\n        }\r\n      }\r\n\r\n      if (debug.compilationTime) {console.time(\"insert dummy lines time\")}\r\n      result = insertDummyLines(lines)\r\n      if (debug.compilationTime) {console.timeEnd(\"insert dummy lines time\")}\r\n\r\n      if (result.error) return result\r\n      lines = result.lines\r\n\r\n      //assign INTERNAL line numbers:\r\n      let i = -1\r\n      lines = lines.map( n => {\r\n        if (!n) {\r\n          console.log(lines, n, i)\r\n          throw new Error(\"Fatal error: line is false! This should never happen.\")\r\n        }\r\n        i++\r\n        n.internalLineNr = i\r\n         return n\r\n      })\r\n\r\n      if (debug.compilationTime) {console.time(\"annotate lines\")}\r\n      result = annotateLines(lines)\r\n      if (result.error) return result\r\n      this.jumpTable = result.jumpTable\r\n      lines = result.lines\r\n      if (debug.compilationTime) {console.timeEnd(\"annotate lines\")}\r\n\r\n      if (debug.compilationTime) {console.time(\"annotate levels\")}\r\n      lines = annotateLevels(lines)\r\n      if (lines.error) return lines\r\n      if (debug.compilationTime) {console.timeEnd(\"annotate levels\")}\r\n\r\n      if (debug.compilationTime) {console.time(\"annotate gathers\")}\r\n      lines = annotateGathers(lines)\r\n      if (lines.error) return lines\r\n      if (debug.compilationTime) {console.timeEnd(\"annotate gathers\")}\r\n      \r\n      if (debug.compilationTime) {console.time(\"annotate choices\")}\r\n      lines = annotateChoices(lines)\r\n      if (lines.error) return lines\r\n      if (debug.compilationTime) {console.timeEnd(\"annotate choices\")}\r\n      \r\n      if (debug.compilationTime) {console.time(\"process choices\")}\r\n      lines = processChoices(lines)\r\n      if (lines.error) return lines\r\n      if (debug.compilationTime) {console.timeEnd(\"process choices\")}\r\n\r\n      if (debug.compilationTime) {console.time(\"annotate blocks\")}\r\n      lines = annotateBlocks(lines)\r\n      if (lines.error) return lines\r\n      if (debug.compilationTime) {console.timeEnd(\"annotate blocks\")}\r\n\r\n      if (debug.compilationTime) {console.time(\"block integrity check\")}\r\n      this.checkBlockIntegrity(lines)\r\n      if (debug.compilationTime) {console.timeEnd(\"block integrity check\")}\r\n\r\n      this.lines = lines\r\n\r\n      if (debug.compilationTime) {\r\n        console.timeEnd(timerString)\r\n      }\r\n\r\n      return {success: true}\r\n    }\r\n\r\n    checkBlockIntegrity(lines) {\r\n      //this is just an additional check to\r\n      //help catch bugs early. the performance penalty should not\r\n      //be too big. If it proves to be big, though, you can remove\r\n      //this check. Otherwise leave it in for more security.\r\n      for (const line of lines) {\r\n        for (const key of [\"correspondingIf\", \"correspondingElse\",\r\n            \"correspondingEnd\"]) {\r\n          if (line[key] !== undefined) {\r\n            const targetLine = lines[Number(line[key])]\r\n            if (!targetLine) {\r\n              console.log(\"ERROR at line: \", line, `line.${key} \r\n                does not point to a valid line. This should never happen.\r\n                line.${key} === ${targetLine}`)\r\n              throw new Error (`Fatal error. See console.log above.`)\r\n            }\r\n\r\n            let err = false\r\n            if (key === \"correspondingIf\" && targetLine.type !== \"if\") err = true\r\n            if (key === \"correspondingElse\" && targetLine.type !== \"else\") err = true\r\n            if (key === \"correspondingEnd\" && targetLine.type !== \"end\"\r\n              && line.type !== \"js-start\") err = true\r\n\r\n            if (key === \"correspondingEnd\" && targetLine.type !== \"js-end\"\r\n              && line.type === \"js-start\") err = true\r\n              \r\n            if (err) {\r\n              console.log(\"error at line:\", line)\r\n              throw new Error(`Fatal error. line.${key} does NOT point to an\r\n                ${key.replace(\"corresponding\", \"\").toLowerCase()} line.\r\n                See console.log above.`)\r\n            }\r\n\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n\r\n    evalText(text) {\r\n      /* evals string containing << >> parts\r\n      and returns new string.\r\n      Because the parts with << >> can contain\r\n      arbitrary JS, this can totally perform side-effects.\r\n      This should only be called on text\r\n      that is printed shortly after that.\r\n      Calling this on text that is not displayed to the player\r\n      should not be done.\r\n      */\r\n      const parts = utils.splitIntoPartsByStartAndEndTags(text, \"<<\", \">>\")\r\n      if (parts.error) {\r\n        const msg = {\r\n          \"nested\": `You cannot nest inline << >> blocks. I found a << or a >> inside\r\n            another << >> block.`,\r\n          \"unclosed\": `Unclosed << block. An inline block starting with << must be \r\n            closed with >>. They also must be in the same text block. (No empty lines in between.)`,\r\n          \"closed\": `I found >>, which tells me to close an inline block, but\r\n            I never found the opening << sequence. Note that the opening << and the closing\r\n            >> must be in the same text block (no empty lines in between).`,            \r\n        }[parts.code]\r\n        const msg2 = `The error occurred in XXX`\r\n        return {error: true, msg: msg + msg2}\r\n      }\r\n      let out = \"\"\r\n      for (let part of parts) {\r\n        if (part.inside) {\r\n          const str = `____asj22u883223232jm_ajuHH23uh23hhhH__**~§@€xX` //prevent collision\r\n          window[str] = false\r\n          try {\r\n            if (part.text.trim() === \"\") {\r\n              return {error: true, msg: `Empty &lt;&lt; &gt;&gt; block. This makes no sense \r\n              to me. I was expecting some expression inside the &lt;&lt; &gt;&gt; This happened\r\n              in XXX`}\r\n            }\r\n            eval (`window[\"${str}\"] = ( ` + part.text + \" )\" )\r\n          } catch(err) {\r\n            const msg = `<< >> block: JavaScript threw an error. Is \r\n              this a valid expression? This happened in XXX<br>${err}`\r\n            return {error: true, msg: msg}\r\n          }\r\n          const result = window[str]\r\n          if (result || result === 0) {\r\n            out += result\r\n          }\r\n        } else {\r\n          out += part.text\r\n        }\r\n      }\r\n      return out\r\n    }\r\n\r\n    convertInlineJs(pars) {\r\n      function convertItem(paragraph) {\r\n        if (errorHappened) return\r\n        let text = paragraph.text\r\n        let result = that.evalText(text)\r\n        if (result.error) {\r\n          errorHappened = true\r\n          const msg = result.msg.replace(\"XXX\", `the text block that ENDED with line ` +\r\n            paragraph.lineNr)\r\n          that.rtError(paragraph.lineNr, msg, false)\r\n          return\r\n        }\r\n        return {\r\n          text: result,\r\n          lineNr: paragraph.lineNr,\r\n          meta: paragraph.meta,\r\n        }\r\n      }\r\n      const that = this\r\n      let errorHappened = false\r\n      pars = pars.map( function (p) {return convertItem(p)} )\r\n      if (errorHappened) return false\r\n      return pars\r\n    }\r\n\r\n    getContents() {\r\n      //public\r\n      return {\r\n        choices: this.choices,\r\n        paragraphs: this.paragraphs,\r\n      }\r\n    }\r\n\r\n\r\n    setState(state) {\r\n      //public\r\n      if (!this.inited) throw `Call story.restart() first.`\r\n      if (!state.isJinxState) throw new Error(`Not a valid Jinx state.`)\r\n      this.resetState()\r\n      this.choices = state.choices\r\n      this.paragraphs = state.paragraphs\r\n    }\r\n    \r\n    getState() {\r\n      //public\r\n      if (!this.inited) throw `Call story.restart() first.`\r\n      return {\r\n        choices: this.choices,\r\n        paragraphs: this.paragraphs,\r\n        isJinxState: true,        \r\n      }\r\n    }\r\n\r\n\r\n    selectChoice(index) {\r\n      //public\r\n      //pass: choiceIndex\r\n      //returns: new content to output\r\n      //updates state according to selected choice\r\n\r\n      index = Number(index)\r\n\r\n      if (debug.logFlow) console.log(\"SELECTED CHOICE\", index)\r\n      if (!this.inited) throw `Call story.restart() first.`\r\n      \r\n      let ch = this.choices[index]\r\n      if (!ch) {\r\n        this.rtError(-666, `Choice with index ${index} does not exist.`)\r\n        return\r\n      }\r\n\r\n      this.flushGatherState()\r\n\r\n      const choice = ch\r\n\r\n      let i = choice.internalLineNr\r\n      let line = this.lines[i]\r\n\r\n      this.lastSelectedChoice = line\r\n\r\n      //console.log(choice, i , line)\r\n      if (!line) {\r\n        this.rtError(choice.lineNr, `Line/choice does not exist?`)\r\n        return\r\n      }\r\n\r\n      //console.log(\"doContinueFromChoice, CONTINUING AT LINE\", i + 1)\r\n      this.pointer =  i + 1\r\n    }\r\n \r\n\r\n    jumpTo(knotOrLabelName) {\r\n      //public\r\n      const target = this.jumpTable[knotOrLabelName]\r\n      if (!target && target !== 0) {\r\n        this.onError({\r\n          error: true,\r\n          type: \"runtime error\",\r\n          lineNr: \"?\",\r\n          lineObj: {},\r\n          msg: `jumpTo: I didn't find a knot or label with name \"${target}\"`,\r\n        })\r\n        return {error: true}\r\n      }\r\n      this.pointer = target\r\n    }\r\n\r\n    \r\n    resetState() {\r\n      //public (but also called from inside the class)\r\n      this.flushGatherState()\r\n      this.flushStoryState()\r\n      this.pointer = 0\r\n      this.inited = true\r\n      this.securityCounter = 0\r\n      this.previouslyExecutedLine = false\r\n    }\r\n\r\n    kickOff() {\r\n      //public\r\n      this.previouslyExecutedLine = false\r\n      this.securityCounter = 0\r\n      this.executeLine(this.pointer)\r\n    }\r\n\r\n    flushStoryState() {\r\n      this.usedUpChoices = {}\r\n      this.lastSelectedChoice = false\r\n    }\r\n\r\n    flushGatherState() {\r\n      this.paragraphBuffer = []\r\n      this.choices = []\r\n      this.lastGlueSet = false\r\n    }\r\n\r\n    rtError(index, msg, lineNrMode = true) {\r\n      /* lineNrMode\r\n        true (default): pass index of line in line array as first parameter\r\n        false: pass actual line number in code\r\n      */\r\n      let line\r\n      if (lineNrMode) {\r\n        line = this.lines[index]\r\n      } else {\r\n        line = this.lines.filter(l => l.lineNr === index)[0]\r\n      }\r\n\r\n      let lnr\r\n      let legal = true\r\n      if (line) {\r\n        lnr = line.lineNr\r\n      } else {\r\n        lnr = -555\r\n        legal = false\r\n      }\r\n      \r\n      this.onError({\r\n        error: true,\r\n        type: \"runtime error\",\r\n        lineNr: lnr,\r\n        lineObj: line,\r\n        msg: msg,\r\n        legal: legal,\r\n        legalMsg: legal ? \"Ok\" : \"Line does not exist?\"\r\n      })\r\n    }\r\n\r\n    capitalize(n) {\r\n      return n.substr(0, 1).toUpperCase() + n.substr(1)\r\n    }\r\n\r\n    executeLine(index) {\r\n\r\n      if (index >= this.lines.length) {\r\n        this.rtError(index, `I reached the last line of the story. ` +\r\n          `I was expecting an .endgame command before that.`)\r\n        return\r\n      }\r\n\r\n      this.securityCounter ++\r\n      //assuming this is the correct line to run. no level checks etc. here.\r\n      let line = this.lines[index]\r\n      //console.log(\"EXECUTING LINE with index:\", index, \"line:\", line)\r\n\r\n      if (this.securityCounter >= this.securityMax) {\r\n        this.rtError(index, \"Max. recursion exceeded. Do you have an infinite loop?\")\r\n        return\r\n      }\r\n\r\n      if (debug.turtle) {\r\n        //turtle does IO. Normally, of course,\r\n        //Jinx should NEVER do IO, but this is just for debugging purposes.\r\n        document.body.innerHTML += `EXECUTING LINE ${line.lineNr || line.type}: ${line.text}<br>`\r\n      }\r\n\r\n      if (debug.logFlow) {\r\n        console.log(`↪ EXECUTING LINE ${line.lineNr} ${line.type}: ${line.text}`,\r\n        \"this.securityCounter:\", this.securityCounter)\r\n      }\r\n\r\n      if (debug.log) console.log(\"running line\", index, line)\r\n      \r\n      if (!line) {\r\n        //this.rtError(index, \"Line does not exist.\")\r\n        console.log(\"Line is: \", line, \"index:\", index)\r\n        throw `Line does not exist`\r\n      }\r\n\r\n      if (!line.type) {\r\n        console.log(line, line.type)\r\n        throw `Line has no type.`\r\n      }\r\n\r\n      const acc = \"exec\" + this.capitalize(line.type.replaceAll(\"-\", \"\"))\r\n      let func = this[acc]\r\n      if (!func) throw `No execution method for line type: ${line.type} @ ${acc}`\r\n      let result = func.bind(this)(line, this.previouslyExecutedLine)\r\n\r\n      this.previouslyExecutedLine = line\r\n      let testGameJustEnded = false\r\n\r\n      if (result === \"advanceByOne\") {\r\n        if (line.continuation) {\r\n          if (line.continuation === \"no-continuation\") {\r\n            this.rtError(-1, `The story seems to just stop here. I expected a\r\n              gather or a goto.\r\n              This happened after the choice \"${this.lastSelectedChoice?.text}\"\r\n              at line ${this.lastSelectedChoice?.lineNr}\r\n              was selected. \r\n              `, false)\r\n            return\r\n          }\r\n          this.pointer = line.continuation\r\n        } else {\r\n          this.pointer += 1\r\n        }\r\n      }\r\n\r\n      if (result && result.jumpTo) {\r\n        this.pointer = result.jumpTo\r\n      }\r\n\r\n      if (result && result.error) {\r\n        this.rtError(index, result.msg)\r\n        return\r\n      }\r\n\r\n      if (result === \"gameEnd\" || result === \"stopRunning\") {\r\n        this.prepareOutput()\r\n        if (result === \"gameEnd\") this.onEvent(\"gameEnd\")\r\n        if (result === \"stopRunning\") this.onEvent(\"finishedCollecting\")  \r\n        return\r\n      }\r\n\r\n      if (!result) {\r\n        throw new Error(`Execution method ${acc} should have returned something, not falsey value.`)\r\n        return\r\n      }\r\n\r\n      if (debug.turtle) {\r\n        setTimeout( () => this.executeLine(this.pointer), debug.turtleSpeed)\r\n      } else {\r\n        this.executeLine(this.pointer)\r\n      }\r\n    }\r\n\r\n\r\n    prepareOutput() {\r\n      /* This is called when a turn has passed (either\r\n        \"gameEnd\" or \"finishedCollecting\" will be fired after this.)\r\n        It prepares the paragraphs and choices, so the runner\r\n        can fetch them via .getContents after that.\r\n        It's important that this is called only once per turn,\r\n        since it's NOT side-effect-free. (It evals << >> blocks inside strings\r\n        to perform text substitutions. Ideally, the user\r\n        should not use side-effect inducing stuff inside << >> blocks,\r\n        if possible, but it's still allowed.)\r\n        todo to do: this probably leads to new values being rendered even if << >> was called\r\n        BEFORE. That is okay, but it's a gotcha. Document it.\r\n        */\r\n      \r\n      //fix up paragraphs:\r\n\r\n      let pars = this.internalGetParagraphs(this.paragraphBuffer)\r\n      pars = this.convertInlineJs(pars)\r\n      if (!pars) return //error occurred. rtError has already been issued.\r\n      this.paragraphs = pars\r\n\r\n\r\n      //fix up choices:\r\n      let choices = this.getFixedUpChoices(this.choices)\r\n      if (!choices) return //error occurred. rtError has already been issued.\r\n      this.choices = choices\r\n\r\n    }\r\n\r\n    //execJsstart(line) {}\r\n\r\n\r\n    getFixedUpChoices(choices) {\r\n      function convertItem(choice) { \r\n        if (errorHappened) return\r\n        let text = choice.text\r\n        let result = that.evalText(text)\r\n        if (result.error) {\r\n          errorHappened = true \r\n          const msg = result.msg.replace(\"XXX\", `the choice on line ` +\r\n            choice.lineNr)\r\n          that.rtError(choice.lineNr, msg, false)\r\n          return\r\n        }\r\n        choice.text = result\r\n        return choice\r\n      }\r\n      const that = this\r\n      let errorHappened = false\r\n      choices = choices.map( function (p) {return convertItem(p)} )\r\n      if (errorHappened) return false\r\n      return choices\r\n    }\r\n\r\n    setTextContentMetaData(data) {\r\n      /* This sets the current meta data that is added to every\r\n      paragraph and every choice element thereafter.\r\n      This can be changed at any time.\r\n      The rationale is that you can call this via JavaScript to set some\r\n      data and the data will then be attached to all following paragraphs and\r\n      choices. The common use case for this is changing the current output container!\r\n      data should be a JSON-serializable object.\r\n      Whan you call this, a new empty line is pushed to the paragraph buffer,\r\n      because a call to setTextContentMetaData always implies that the last paragraph\r\n      CANNOT be glued together with the next one, since they may have\r\n      different metadata!\r\n      */\r\n      this.paragraphBuffer.push({type: \"empty-line\"})\r\n      this.currentTextContentMetaData = data\r\n    }\r\n\r\n    \r\n    internalGetParagraphs(buffer) {\r\n      //this processes the paragraphBuffer list into the actual paragraph list:\r\n\r\n      //do not modify buffer directly, instead clone it:\r\n      let list = buffer.map(n => n)\r\n\r\n      //1. if the first item is an empty line, remove it / if the last\r\n      //item is an empty line, remove it:\r\n      list = list.filter( (item, index) => {\r\n          if (index === 0 && item.type === \"empty-line\") return false\r\n          if (index === list.length - 1 && item.type === \"empty-line\") return false          \r\n          return true\r\n        }\r\n      )\r\n\r\n      //2. collapse duplicate glue tokens into one:\r\n      list = utils.filterIfPrevious(list, (prev, item) => {\r\n        if (prev.type === \"glue\" && item.type === \"glue\") return false\r\n        return true\r\n      })\r\n\r\n      //3. if an empty line is preceded by a glue token,\r\n      //remove the empty line entirely (it has no meaning. duplicate empty lines\r\n      //should never occur, that is taken care of beforehand) same if\r\n      //the empty line is followed by a glue token.\r\n      list = utils.filterIfPrevious(list, (prev, item) => {\r\n        if (prev.type === \"glue\" && item.type === \"empty-line\") return false\r\n        return true\r\n      })\r\n\r\n      list = utils.filterIfNext(list, (item, next) => {\r\n        if (item.type === \"empty-line\" && next.type === \"glue\") return false\r\n        return true\r\n      })\r\n\r\n      /* 4. create the paragraph list and first paragraph item,\r\n        then loop through the list of items:\r\n        if text line:\r\n          add it to the current paragraph (last paragraph in list) content + add a space\r\n        if empty line:\r\n          create a new paragraph and push it onto the paragraph list\r\n        if glue token:\r\n          remove last space from paragraph content\r\n      */\r\n      \r\n      let paragraphs = [{text: \"\"}]\r\n\r\n      for (let item of list) {\r\n        if (item.type === \"text\") {\r\n          const currentParagraph = paragraphs[paragraphs.length - 1]\r\n          currentParagraph.text += item.text + \" \"\r\n          currentParagraph.lineNr = item.lineNr\r\n          currentParagraph.meta = item.meta\r\n        } else if (item.type === \"empty-line\") {\r\n          paragraphs.push({text: \"\"})\r\n        } else if (item.type === \"glue\") {\r\n          const currentParagraph = paragraphs[paragraphs.length - 1]\r\n          if (currentParagraph.text.length) {\r\n            if (currentParagraph.text[currentParagraph.text.length - 1] !== \" \") {\r\n              throw new Error (`Glue error. Paragraph should end with space.`)\r\n            }\r\n            currentParagraph.text = currentParagraph.text\r\n              .substr(0, currentParagraph.text.length - 1) //VS code\r\n              //likes to strike-through the substr, but that's nonsense.\r\n          }\r\n        } else {\r\n          throw new Error(\"Illegal paragraph type.\")\r\n        }\r\n      }\r\n\r\n      //5. remove empty paragraphs:\r\n      paragraphs = paragraphs.filter(n => n.text)\r\n\r\n      return paragraphs\r\n    }\r\n\r\n    execJsstart(line) {\r\n      console.log(\"execing js\", line)\r\n      return \"advanceByOne\"\r\n    }\r\n\r\n    execJsend(line) {\r\n      console.log(\"execing js end\", line)\r\n      return \"advanceByOne\"\r\n    }\r\n\r\n    execEmpty(line) {\r\n      //empty line (paragraph delimiter)\r\n      this.paragraphBuffer.push({type: \"empty-line\"})\r\n      return \"advanceByOne\"\r\n    }\r\n \r\n    execText(line) {\r\n      let text = line.text\r\n      let startGlue = false\r\n      let endGlue = false\r\n      if (text.startsWith(GLUESYMBOL)) {\r\n        text = text.substr(2)\r\n        startGlue = true\r\n      }\r\n      if (text.endsWith(GLUESYMBOL)) {\r\n        text = text.substr(0, text.length - 2)\r\n        endGlue = true\r\n      }\r\n      if (startGlue) this.paragraphBuffer.push({type: \"glue\"})\r\n      this.paragraphBuffer.push({type: \"text\", text, lineNr: line.lineNr,\r\n        meta: this.currentTextContentMetaData})\r\n      if (endGlue) this.paragraphBuffer.push({type: \"glue\"})\r\n      return \"advanceByOne\"\r\n    }\r\n\r\n    execLabel(line) {\r\n      //nothing at the moment\r\n      return \"advanceByOne\"\r\n    }\r\n\r\n    execIf(line) {\r\n      const str = `____asj22u883223232jm_ajuHH23uh23hhhH__**~§@€` //prevent collision\r\n      window[str] = false\r\n      try {\r\n        eval (`window[\"${str}\"] = ( ` + line.text+ \" )\" )\r\n      } catch(err) {\r\n        this.rtError(line.lineNr, \"if-condition: JavaScript threw an error. Is this a valid condition?\"+\r\n          `<br>${err}`, false)\r\n        return \"stopRunning\"\r\n      }\r\n      let target = false\r\n      if (!window[str]) {\r\n        //condition failed:\r\n        //jump to corresponding else, if there is one, otherwise to corresponding end\r\n        if (line.correspondingElse) {\r\n          target = line.correspondingElse + 1\r\n        } else {\r\n          target = line.correspondingEnd\r\n        }\r\n      } else {\r\n        //condition succeeded\r\n        return \"advanceByOne\"\r\n      }\r\n\r\n      if (!target) {\r\n        this.rtError(line.lineNr, 'if-condition seems to have no valid \"end\" command.')\r\n        return\r\n      }\r\n      \r\n      //console.log(\"execIf, going to\", target)\r\n      return {jumpTo: target}\r\n    }\r\n    \r\n    execElse(line) {\r\n      //jump to corresponding end\r\n      if (!line.correspondingEnd) throw new Error(`else has no if/end block? This should not happen.`)\r\n      \r\n      console.log(\"IAM Else LINE\", line)\r\n      const target = line.correspondingEnd\r\n      if (debug.logFlow) {\r\n        console.log(\"ELSE TARGET IS:\", target)\r\n      }\r\n      return {jumpTo: target}\r\n    }\r\n    \r\n    execEnd(line) {\r\n      //nothing else at the moment\r\n      return \"advanceByOne\"\r\n    }\r\n\r\n    execComment(line) {\r\n      //nothing else\r\n      return \"advanceByOne\"\r\n    }\r\n\r\n    execChoice(line) {\r\n      //populate this.choices with choice objects containing choice text\r\n      //(for once-only choices, future: assumes that lineNr of choice is unique,\r\n      //which it really should be, unless there is a serious bug)\r\n\r\n      if (this.previouslyExecutedLine && this.previouslyExecutedLine.level !==\r\n        line.level) {\r\n          return {\r\n            error: true,\r\n            msg: `Encountered choice of wrong level. Maybe you forgot a gather?`,\r\n          }\r\n      }\r\n\r\n      if (!line.nextChoiceOfSameLevel) {\r\n        console.log(\"erroneous line:\", line)\r\n        throw new Error(`Fatal. Choice has no nextChoiceOfSameLevel.`)\r\n      }\r\n\r\n      let choice = {\r\n        text: line.text,\r\n        level: line.level,\r\n        subType: line.subType,\r\n        index: this.choices.length,\r\n        internalLineNr: line.internalLineNr,\r\n        lineNr: line.lineNr,\r\n        meta: this.currentTextContentMetaData,\r\n      }\r\n\r\n      let conditionOk = true\r\n\r\n      if (line.ifCondition) {\r\n        conditionOk = false\r\n        const str = `____asj22u883223232jm_ajuHH23uh23hhhH__**~§@€xXyY` //prevent collision\r\n        window[str] = false\r\n        try {\r\n          eval (`window[\"${str}\"] = ( ` + line.ifCondition + \" )\" )\r\n        } catch(err) {\r\n          this.rtError(line.lineNr, `choice: if condition: JavaScript threw an error. Is \r\n            this a valid expression?\r\n            <br>${err}`, false)\r\n          return \"stopRunning\"\r\n        }\r\n        conditionOk = window[str]\r\n      }\r\n\r\n      if (conditionOk) {\r\n        this.choices.push(choice)\r\n      }\r\n      \r\n\r\n      if (line.nextChoiceOfSameLevel === \"endBlock\") {\r\n        return \"stopRunning\"\r\n      }\r\n\r\n      return {jumpTo: line.nextChoiceOfSameLevel}\r\n    }\r\n\r\n    log(msg) {\r\n      //if (!debug.log) return\r\n      console.log(\"%c \" + msg, \"background: pink; color: black;\")\r\n    }\r\n\r\n    execSinglelinejs(line) {\r\n      //console.log(\"exec single line js\", line)\r\n      try {\r\n        eval(line.text)\r\n      } catch(err) {\r\n        this.rtError(line.lineNr, `I executed a single JavaScript line and ran into an error.\r\n          <br><br>This is the line:\r\n          <br>${line.text}\r\n          <br><br>This is the error:\r\n          <br>${err.message}\r\n          `, false)\r\n      }\r\n      return \"advanceByOne\"\r\n    }\r\n\r\n    execGoto(line) {\r\n      const target = this.jumpTable[line.target]\r\n      if (!target && target !== 0) {\r\n        return {\r\n          error: true,\r\n          msg: `.goto ${line.target}: I didn't find a knot or label with this name.`,\r\n        }\r\n      }\r\n      return {jumpTo: target + 1}\r\n    }\r\n\r\n    execKnot(line) {\r\n      return \"stopRunning\"\r\n    }\r\n    \r\n    execEndgame(line) {\r\n      return \"gameEnd\"\r\n    }\r\n\r\n    execGather(line) {\r\n      return \"advanceByOne\"\r\n    }\r\n\r\n    execVoid() {\r\n      //dummy lines. do absolutely nothing\r\n      return \"advanceByOne\"\r\n    }\r\n\r\n  } //Class story\r\n\r\n\r\n  function insertDummyLines(lines) {\r\n    let nu = []\r\n    for (let line of lines) {\r\n      nu.push(line)\r\n      if (line.type === \"choice\") {\r\n        nu.push({\r\n          type: \"void\",\r\n          level: line.level + 1,\r\n        })\r\n      }\r\n    }\r\n    return {\r\n      lines: nu,\r\n      error: false,\r\n    }\r\n  }\r\n\r\n\r\n  //####################\r\n  //####################\r\n\r\n\r\n  function annotateBlocks(lines) {\r\n    \r\n    function An(str) {\r\n      const char = str.substr(0, 1).toLowerCase()\r\n      if ([\"a\", \"e\", \"i\", \"o\", \"u\"].includes(char)) {\r\n        return \"An\"\r\n      }\r\n      return \"A\"\r\n    }\r\n\r\n    function getUnclosedBlockError(stack, line) {\r\n      let lastLine = stack[stack.length - 1]\r\n      let txt = \r\n        `${stack.length} unclosed block${stack.length > 1 ? \"s\" : \"\"}. `+\r\n        `${An(lastLine.type)} ${lastLine.type} block was opened on ` +\r\n        `line ${lastLine.lineNr} and ` + \r\n        `it should have been closed before line ${line.lineNr}.`\r\n      return {\r\n        error: true,\r\n        lineNr: line.lineNr,\r\n        lineObj: line, \r\n        msg: txt,\r\n      }\r\n    }\r\n\r\n    //if for each loop end endjs else processing\r\n    let currentLevel = -1000\r\n    let stack = []\r\n    let index = -1\r\n    for (let line of lines) {\r\n      index ++\r\n      let t = line.type\r\n      if (line.level !== currentLevel) {\r\n        if (stack.length) {\r\n          return getUnclosedBlockError(stack, line)\r\n        }\r\n        stack = []\r\n      }\r\n      \r\n      if (\r\n        t === \"if\" ||\r\n        t === \"loop\" ||\r\n        t === \"each\" ||\r\n        t === \"for\" ||\r\n        t === \"js-start\"\r\n      ) {\r\n        stack.push(line)\r\n      } else if (t === \"else\") {\r\n        let lastLine = stack[stack.length - 1]\r\n        if (!lastLine) {\r\n          return {\r\n            error: true,\r\n            lineNr: line.lineNr,\r\n            lineObj: line,\r\n            msg: `I found an \".else\" line, but there was no \".if\" line before that, so it\r\n              makes no sense to me.`,\r\n          }\r\n        }\r\n        lastLine.correspondingElse = line.internalLineNr\r\n        lastLine.correspondingElseObj = line\r\n        if (lastLine.type !== \"if\") {\r\n          return {\r\n            error: true,\r\n            lineNr: line.lineNr,\r\n            lineObj: line, \r\n            msg: `\".else\" may only appear inside an \".if\" block`,\r\n          }\r\n        }\r\n        line.correspondingIf = lastLine.internalLineNr\r\n      } else if (t === \"end\" || t === \"js-end\") {\r\n        let lastLine = stack[stack.length - 1]\r\n        if (!lastLine) {\r\n          return {\r\n            error: true,\r\n            lineNr: line.lineNr,\r\n            lineObj: line,\r\n            msg: `I found an \".end\" or \".jsend\" line, but there was no block\r\n              to close, so it makes no sense to me.`,\r\n          }\r\n        }\r\n        if (t === \"js-end\" && lastLine.type !== \"js-start\") {\r\n          return {\r\n            error: true,\r\n            lineNr: line.lineNr,\r\n            lineObj: line, \r\n            msg: `A normal block should be closed with \".end\", not with \".jsend\".`,\r\n          } \r\n        }\r\n        if (t === \"end\" && lastLine.type === \"js-start\") {\r\n          return {\r\n            error: true,\r\n            lineNr: line.lineNr,\r\n            lineObj: line, \r\n            msg: `A \".js\" block should be closed with \".jsend\", not with \"end\".`,\r\n          }    \r\n        } \r\n        if (!stack.length) {\r\n          return {\r\n            error: true,\r\n            lineNr: line.lineNr,\r\n            lineObj: line, \r\n            msg: ` I found \".end\", but there is no block to close.`,\r\n          }  \r\n        }\r\n        let last = stack.pop()\r\n        last.correspondingEnd = line.internalLineNr\r\n        if ( t === \"end\" ) {\r\n          const lastIf = last\r\n          if (lastIf.correspondingElseObj) {\r\n            lastIf.correspondingElseObj.correspondingEnd = line.internalLineNr\r\n            delete lastIf.correspondingElseObj //not needed anymore\r\n          }\r\n        }\r\n      }\r\n      currentLevel = line.level\r\n    }\r\n    //console.log(\"stack\", stack, stack.length, JSON.stringify(stack[0]))\r\n\r\n    if(stack.length) {\r\n      const lastLine = stack[stack.length - 1]\r\n      let txt = \r\n        `${stack.length} unclosed block${stack.length > 1 ? \"s\" : \"\"}. `+\r\n        `${An(lastLine.type)} ${lastLine.type} block was opened on ` +\r\n        `line ${lastLine.lineNr} and ` + \r\n        `should have been closed.`\r\n      return {\r\n        error: true,\r\n        lineNr: lastLine.lineNr,\r\n        lineObj: lastLine, \r\n        msg: txt,\r\n      }\r\n    }\r\n\r\n    return lines\r\n  } //annotateBlocks\r\n\r\n\r\n  function tokenize(str) {\r\n    let lines = str.split(\"\\n\").map( (line, i) => {\r\n      let type = false\r\n      let subType = false\r\n      line = line.trim()\r\n\r\n      if (line === \"\") {\r\n        type = \"empty\"\r\n      }\r\n\r\n      if ( line.startsWith(\"===\") ) {\r\n        type = \"knot\"\r\n      } else if ( line.startsWith(\"=\") ) {\r\n        type = \"label\"\r\n      } else if ( line.startsWith(\"*\") ) {\r\n        type = \"choice\"\r\n        subType = \"once\"\r\n      } else if ( line.startsWith(\"+\") ) {\r\n        type = \"choice\"\r\n        subType = \"multi\"\r\n      } else if ( line.startsWith(\"-\") ) {\r\n        type = \"gather\"\r\n      } else if ( line.startsWith(\"#\") ) {\r\n        type = \"single-line-js\"\r\n      } else if ( line.startsWith(\".goto \") || line.startsWith(\".g \") ) {\r\n        type = \"goto\"\r\n      } else if ( line.startsWith(\"//\") ) {\r\n        //comment\r\n        return { type: \"comment\" }\r\n      } else if (line.startsWith(\".\")) {\r\n        let res = getDotCommandType(line)\r\n        if (!res) {\r\n          return {\r\n            error: true,\r\n            msg: `Unknown dot command: ${line}`,\r\n            lineNr: i + 1,\r\n            lineObj: false,\r\n          }\r\n        }\r\n        type = res\r\n      } else if (type !== \"empty\") {\r\n        type = \"text\"\r\n      }\r\n\r\n      const o = {\r\n        type: type,\r\n        subType: subType,\r\n        text: line,\r\n        lineNr: i + 1, //(starting from 1 not 0)\r\n      }\r\n\r\n      return o\r\n    })\r\n      //lines = lines.filter( n => n ) NO! JUST NO!\r\n    /*lines = lines.map ( n => {\r\n      if (!n) return {\r\n        type: \"empty\",\r\n      }\r\n      return n\r\n    })*/\r\n    for (let line of lines) {\r\n      const res = checkLineSyntax(line)\r\n      if (res) return {\r\n        error: true,\r\n        msg: res,\r\n        lineNr: line.lineNr,\r\n        lineObj: line,\r\n      }\r\n    }\r\n    return lines\r\n  }\r\n\r\n  function checkLineSyntax(line) {\r\n    //return falsey value for: everything fine.\r\n    //return string for: error occurred, show this error message.\r\n    //each line has to go through here\r\n    const type = line.type\r\n    const mustBeSingle = new Set([\"else\", \"js\", \"jsend\", \"end\", \"endgame\"])\r\n    if ( mustBeSingle.has(type) ) {\r\n      const wordAmount = line.text.replace(\".\", \"\")\r\n        .trim().split(\" \").map(n => n.trim()).filter(n => n).length  \r\n      if (wordAmount > 1) {\r\n        return `${type} line cannot contain additional text. I saw ${wordAmount} words on that line, \r\n        but only the first one makes sense to me.`\r\n      }\r\n    }\r\n\r\n    if (type === \"gather\") {\r\n      if (line.text.replaceAll(\"-\", \"\").trim() !== \"\") {\r\n        return `A gather line cannot contain additional text. I was just expecting\r\n        minus characters on that line, nothing else.`\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n\r\n  function getDotCommandType(line) {\r\n    //return falsey, if not a valid dot command,\r\n    //else return string representing the type\r\n    let type = false\r\n    line = line.replace(\".\", \"\").trim()\r\n\r\n    const firstWord = line.split(\" \").map(n => n.trim()).filter(n => n)[0]\r\n\r\n    if ( firstWord === \"js\" ) {  //currently not supported\r\n      type = \"js-start\"\r\n      type = false\r\n    } else if ( firstWord === \"jsend\" ) {  //currently not supported\r\n      type = \"js-end\"\r\n      type = false\r\n    } else if ( firstWord === \"if\" ) {\r\n      type = \"if\"\r\n    } else if ( firstWord === \"else\" ) {\r\n      type = \"else\"\r\n    } else if (firstWord === \"end\" ) {\r\n      type = \"end\"\r\n    } else if ( firstWord === \"each \" ) {\r\n      type = \"each\"\r\n      type = false //currently not supported\r\n    } else if ( firstWord === \"loop \" ) {\r\n      type = \"loop\"\r\n      type = false //currently not supported\r\n    } else if ( firstWord === \"for \" ) {\r\n      type = \"for\"\r\n      type = false //currently not supported\r\n    } else if ( firstWord === \"choice \" ) {\r\n      type = \"make-choice\"\r\n    } else if ( firstWord === \"set \") {\r\n      type = \"set\"\r\n      type = false //currently not supported\r\n    } else if ( firstWord === \"endgame\") {\r\n      type = \"end-game\"\r\n    } else if ( firstWord === \"goto\" || firstWord === \"g\") {\r\n      type = \"goto\"\r\n    }\r\n    return type\r\n  }\r\n\r\n\r\n  function annotateLines(lines) {\r\n    function getWords(text) {\r\n      return text.trim().split(/\\s/).map(n => n.trim()).filter(n => n)\r\n    }\r\n    function annotateLine(line, index) {\r\n      //line.index = index\r\n      if (line.type === \"knot\" || line.type === \"label\") {\r\n        let amount = 1\r\n        line.name = line.text\r\n        if (line.type === \"knot\") amount = 3\r\n        for (let i = 0; i < amount; i++) {\r\n          line.name = line.name.replace(\"=\", \"\")\r\n        } \r\n        if (line.name.includes(\"=\")) {\r\n          return {\r\n            error: true,\r\n            lineNr: line.lineNr,\r\n            lineObj: line,\r\n            msg: `Wrong number of equals symbols.\r\n              For a knot, use === at the beginning of the line, for a label use =\r\n              at the beginning of the line.\r\n              &nbsp;&nbsp;&nbsp;&nbsp;(This error may also mean that\r\n              your ${line.type} name contains\r\n              an equals symbol - which is not allowed.)`,       \r\n          }\r\n        }\r\n        line.name = line.name.toLowerCase().trim()\r\n        const words = getWords(line.name)\r\n        if (words.length > 1) {\r\n          return {\r\n            error: true,\r\n            lineNr: line.lineNr,\r\n            lineObj: line,\r\n            msg: `A ${line.type} name can only be one word long.\r\n            (To improve readability, you can use underscores to separate individual words.)`,       \r\n          }\r\n        }        \r\n        let n = jumpTable[line.name]\r\n        if (n || n === 0) return {\r\n          error: true,\r\n          lineNr: line.lineNr,\r\n          lineObj: line,\r\n          msg: `${line.name}': duplicate knot/label name`,\r\n        }\r\n        jumpTable[line.name] = index\r\n      } else if (line.type === \"goto\") {\r\n        line.target = line.text\r\n          .replace(\".\", \"\")\r\n          .replace(\"g \", \"\")\r\n          .replace(\"goto \", \"\")\r\n          .toLowerCase()\r\n          .trim()\r\n        const words = getWords(line.target)\r\n        if (words.length > 1) {\r\n          return {\r\n            error: true,\r\n            lineNr: line.lineNr,\r\n            lineObj: line,\r\n            msg: `I was expecting only one word after .goto (the name of a knot or label.)`,       \r\n          }\r\n        }\r\n      } else if (line.type === \"choice\" || line.type === \"gather\") {\r\n        let targetChar = \"+\"\r\n        if (line.subType === \"once\") targetChar = \"*\"\r\n        if (line.type === \"gather\") targetChar = \"-\"\r\n        let count = 0\r\n        let index = -1\r\n        for (let char of line.text) {\r\n          index ++\r\n          if (char.trim() === \"\") continue\r\n          if (char === targetChar) {\r\n            count ++\r\n            continue\r\n          }\r\n          line.text = line.text.substr(index)\r\n          break\r\n        }\r\n        line.level = count\r\n      } else if (line.type === \"if\") {\r\n        line.text = line.text.replace(\".if\", \"\").trim()\r\n      } else if (line.type === \"each\") {\r\n        line.text = line.text.replace(\".each\", \"\").trim()\r\n      } else if (line.type === \"loop\") {\r\n        line.text = line.text.replace(\".loop\", \"\").trim()\r\n      } else if (line.type === \"for\") {\r\n        line.text = line.text.replace(\".for\", \"\").trim()\r\n      } else if (line.type === \"choice\") {\r\n        line.text = line.text.replace(\".choice\", \"\").trim()\r\n      } else if (line.type === \"set\") {\r\n        line.text = line.text.replace(\".set\", \"\").trim()\r\n      } else if (line.type === \"single-line-js\") {\r\n        line.text = line.text.replace(\"#\", \"\").trim()\r\n      }\r\n    \r\n      return line\r\n    }\r\n\r\n    let jumpTable = {}\r\n    let i = -1\r\n    for (let line of lines) {\r\n      i++\r\n      let res = annotateLine(line, i)\r\n      if (res.error) {\r\n        return res\r\n      }\r\n      lines[i] = line\r\n    }\r\n    return {\r\n      lines: lines,\r\n      jumpTable: jumpTable,\r\n    }\r\n  }\r\n\r\n\r\n  function annotateLevels(lines) {\r\n    //add level info to lines:\r\n    let level = 1\r\n    for (let line of lines) {\r\n      if (line.type === \"knot\") {\r\n        line.level = 1\r\n        level = 1\r\n      } else if (line.type === \"gather\") {\r\n        level = line.level\r\n      } else if (line.type === \"choice\") {\r\n        level = line.level + 1\r\n      } else {\r\n        line.level = level\r\n      }\r\n    }\r\n    return lines\r\n  }\r\n\r\n  function processChoices(lines) {\r\n    let error = false\r\n    lines = lines.map (line => {\r\n      if (error) return line\r\n      if (line.type === \"choice\") {\r\n        const text = line.text.trim()\r\n        if (text.startsWith(\"(\")) {\r\n          if (text.replace(\"(\", \"\").trim().startsWith(\"if \")) {\r\n            const index = line.text.indexOf(\")\")\r\n            if (index === -1) {\r\n              error = {\r\n                error: true,\r\n                lineNr: line.lineNr,\r\n                msg: `Choice with if-condition: I am missing\r\n                a closing bracket ) for \r\n                the if-condition.`,\r\n              }\r\n              return line\r\n            }\r\n            const part1 = line.text.substr(0, index + 1)\r\n            const part2 = line.text.substr(index + 1)\r\n            line.ifCondition = part1.replace(\"if\", \"\")\r\n            line.text = part2\r\n            return line\r\n          }\r\n        }\r\n      }\r\n      return line\r\n    })\r\n    if (error) return error\r\n    return lines\r\n  }\r\n\r\n  function annotateChoices(lines) {\r\n    /* \r\n      Here's what happens:\r\n      We walk from top to bottom.\r\n\r\n      If we meet a choice:\r\n      - l is the level of this choice\r\n      - all choices with level higher than l (so 3, 4, 5 etc.,\r\n      if choice is 2, for example) in the hashmap get a nextChoiceOfSameLevel\r\n      property of \"endBlock\", because they are the last choices in their block,\r\n      since the lower-level choice indicated that their block was closed.\r\n      - if the hashmap entry lastChoiceOfLevel[l]\r\n        points to a choice, then that choice gets nextChoiceOfSameLevel = the current index\r\n        (if not, it must be the first choice in the block)\r\n      - the hashmap entry lastChoiceOfLevel[l] becomes a reference to the current choice\r\n\r\n      If we meet a gather:\r\n      - l is the level of the gather\r\n      - all choices in the hashmap with level higher than l OR EQUAL TO l get a\r\n      property nextChoiceOfSameLevel of \"endBlock\"\r\n      \r\n      If we meet a knot start:\r\n      - clear the hashmap\r\n\r\n    */\r\n\r\n    let i = -1\r\n    const lastChoiceByLevel = []\r\n    let lastChoiceLevel = -1\r\n    for (let line of lines) {\r\n      i++\r\n      const index = i\r\n      if (line.type === \"choice\") {\r\n        const level = line.level\r\n        const diff = level - lastChoiceLevel\r\n        if (lastChoiceLevel > 0 && diff > 1) {\r\n          return {\r\n            lineNr: line.lineNr,\r\n            error: true,\r\n            msg: `I found a jump from choice level ${lastChoiceLevel} to choice level ${level}. `+\r\n            `I was expecting at least one level ${lastChoiceLevel + 1} choice in between, `+\r\n            `otherwise it makes no sense.`,\r\n          }\r\n        }\r\n        let i = level\r\n        while (true) {\r\n          i++\r\n          const entry = lastChoiceByLevel[i]\r\n          if (!entry) break\r\n          entry.nextChoiceOfSameLevel = \"endBlock\"\r\n        }\r\n        const prevLine = lastChoiceByLevel[line.level]\r\n        if (prevLine) {\r\n          prevLine.nextChoiceOfSameLevel = line.internalLineNr\r\n        }\r\n        lastChoiceByLevel[line.level] = line\r\n        lastChoiceLevel = line.level\r\n      //####################################\r\n      } else if (line.type === \"gather\") {\r\n        const level = line.level\r\n        let i = line.level - 1\r\n        while (true) {\r\n          i++\r\n          const entry = lastChoiceByLevel[i]\r\n          if (!entry) break\r\n          entry.nextChoiceOfSameLevel = \"endBlock\"\r\n          lastChoiceByLevel[i] = false\r\n        }\r\n      //####################################\r\n      } else if (line.type === \"knot\" || index >= lines.length - 1 ) {\r\n        const level = line.level\r\n        let i = 0\r\n        while (true) {\r\n          i++\r\n          const entry = lastChoiceByLevel[i]\r\n          if (!entry) break\r\n          entry.nextChoiceOfSameLevel = \"endBlock\"\r\n          lastChoiceByLevel[i] = false\r\n        }\r\n      }\r\n    } //for each lines\r\n\r\n    return lines\r\n\r\n  }\r\n\r\n  function annotateGathers(lines) {\r\n    function getNextGather(lines, startIndex, maxLevel) {\r\n      //maxLevel: level must be lower than or equal to this\r\n      for (let i = startIndex; i < lines.length; i++) {\r\n        let line = lines[i]\r\n        if (line.type === \"gather\" && line.level <= maxLevel) {\r\n          return {index: i}\r\n        }\r\n      }\r\n      return false\r\n    }\r\n\r\n    //now walk through lines. whenever the level\r\n    //gets lower (numerically, so from 2 to 1, from 4 to 2 etc.), look for a lower\r\n    //or equal-level gather and\r\n    //connect the line to that gather\r\n\r\n    let i = -1\r\n\r\n    for (let line of lines) {\r\n      i++\r\n      let nextLine = lines[i + 1] || false\r\n\r\n      if (!nextLine) continue\r\n\r\n      //console.log(\"walking to\", i, line)\r\n\r\n      let mode = false\r\n      \r\n      if (nextLine.level < line.level) {\r\n        //console.log(\"nextLine.level:\", nextLine.level, \"line.level:\", line.level)\r\n        mode = true //\"addContinuation\"\r\n      }\r\n\r\n      if (mode) {\r\n        let gather = getNextGather(lines, i + 1, line.level - 1)\r\n        if (!gather) {\r\n          line.continuation = \"no-continuation\"\r\n          //console.log(\"line\", line.lineNr, line.text, \"gets gathered : never\")\r\n        } else {\r\n          //console.log(\"connecting line\", i, \":\", line, \"to line\", gather.index, lines[gather.index] )\r\n          line.continuation = gather.index\r\n          //console.log(\"line\", line.lineNr, line.text, \"gets gathered at\", lines[gather.index])\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    return lines\r\n  }\r\n\r\n  function normalizeWhitespace(str) {\r\n    return str.replace(/\\t/g, \" \")\r\n  }\r\n\r\n  function setDebugOption(option, value = true) {\r\n    //value should be true or false, option should be string\r\n    debug[option] = value\r\n  }\r\n\r\n  return {\r\n    createNewStory,\r\n    setDebugOption,\r\n  }\r\n\r\n})()\r\n\r\n","Meta":"./runtime/jinx.js"}